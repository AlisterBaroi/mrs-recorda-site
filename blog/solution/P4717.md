---
title: '题解：P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)'
date: 2025-08-06T19:00
authors: [lailai]
tags: [solution, luogu]
---

## 原题链接

- [洛谷 P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)](https://www.luogu.com.cn/problem/P4717)

<!-- truncate -->

## 参考资料

- [P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT) 题解 - 洛谷](https://www.luogu.com.cn/problem/solution/P4717)
- [快速沃尔什变换 - OI Wiki](https://oi-wiki.org/math/poly/fwt/)
- [容斥原理 - OI Wiki](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)
- [前缀和 & 差分 - OI Wiki](https://oi-wiki.org/basic/prefix-sum/)
- [FMT（快速莫比乌斯变换） - 秋钧 - 知乎](https://zhuanlan.zhihu.com/p/672965753)
- [容斥原理与子集卷积（四） - 好地方bug - 知乎](https://zhuanlan.zhihu.com/p/33328788)
- [Fast Walsh–Hadamard transform - Wikipedia](https://en.wikipedia.org/wiki/Fast_Walsh–Hadamard_transform)
- [Prefix sum - Wikipedia](https://en.wikipedia.org/wiki/Prefix_sum)

## 题意简述

给定长度为 $2^n$ 的两个序列 $A,B$，设：

$$
C_k=\sum_{i\oplus j=k}A_i\times B_j
$$

分别当 $\oplus$ 是 $\operatorname{or},\operatorname{and},\operatorname{xor}$ 时求出 $C$。

## 解题思路

### 引入

**快速傅立叶变换**（Fast Fourier Transform，FFT）可以 $O(n\log n)$ 计算 **加法卷积**（多项式乘法）：

$$
C_k=\sum_{i+j=k}A_i\times B_j
$$

如果将求和符号的 **加法**（$+$）替换为 **位运算**（$\operatorname{or},\operatorname{and},\operatorname{xor}$），变成 **位运算卷积** 该如何处理呢？

直接枚举的时间复杂度为 $O(n^2)$，效率太低，因此需要使用 FMT 和 FWT。

### 简介

**快速莫比乌斯变换**（Fast Möbius Transform，FMT）可以 $O(n\log n)$ 计算 **或卷积** 和 **与卷积**：

$$
C_k=\sum_{i\operatorname{or} j=k}A_i\times B_j
$$

$$
C_k=\sum_{i\operatorname{and} j=k}A_i\times B_j
$$

**快速沃尔什变换**（Fast Walsh Transform，FWT）可以 $O(n\log n)$ 计算 **异或卷积** 和 **同或卷积**：

$$
C_k=\sum_{i\operatorname{xor} j=k}A_i\times B_j
$$

$$
C_k=\sum_{i\operatorname{xnor} j=k}A_i\times B_j
$$

有些地方会将 FMT 和 FWT 统称为 FWT。

### 思想

类似 FFT，首先 $O(n\log n)$ 进行 **正变换**：

$$
A\xrightarrow{\text{FMT/FWT}}\operatorname{FMT/FWT}[A]
$$

$$
B\xrightarrow{\text{FMT/FWT}}\operatorname{FMT/FWT}[B]
$$

然后 $O(n)$ **逐位相乘**（点积）：

$$
\operatorname{FMT/FWT}[C]=\operatorname{FMT/FWT}[A]\cdot\operatorname{FMT/FWT}[B]
$$

最后 $O(n\log n)$ 通过 **逆变换** 得到结果：

$$
\operatorname{FMT/FWT}[C]\xrightarrow{\text{IFMT/IFWT}}C
$$

接下来，考虑如何构造变换规则。

### 说明

每个二进制数可以看作一个 **集合**，其中二进制位为 $1$ 的位置代表集合中的元素。

两个数的 **按位或运算** 相当于两个集合的 **并集**，而 **按位与运算** 则相当于 **交集**。

而超集就是补集的子集的补集，本质上就是把 $0/1$ 取反，所以子集和超集是对称的。

$$
T\supseteq S\iff \overline{T}\subseteq \overline{S}
$$

## 快速莫比乌斯变换（FMT）

### 原理

如果 $i\operatorname{or}/\operatorname{and} j=k$，即 $i$ 和 $j$ 的并集/交集为 $k$，那么 $i$ 和 $j$ 必定是 $k$ 的子集/超集。

$$
i\operatorname{or} j=k\Rightarrow i\subseteq k\land j\subseteq k
$$

$$
i\operatorname{and} j=k\Rightarrow i\supseteq k\land j\supseteq k
$$

我们可以构造：

$$
\operatorname{FMT_{or}}[A]_k=\sum_{i\subseteq k}A_{i}
$$

$$
\operatorname{FMT_{and}}[A]_k=\sum_{i\supseteq k}A_{i}
$$

这两个式子称为 **子集和**（Sum Over Subsets）和 **超集和**（Sum Over Supersets）。

那么：

$$
\begin{aligned}
  \operatorname{FMT_{or}}[A]_k\cdot \operatorname{FMT_{or}}[B]_k &= \left(\sum_{i\subseteq k} A_i\right)\times \left(\sum_{j\subseteq k} B_j\right) \\
  &= \sum_{i\subseteq k}\sum_{j\subseteq k}A_i\times B_j \\
  &= \sum_{i\cup j\subseteq k}A_i\times B_j \\
  &= \operatorname{FMT_{or}}[C]_k
\end{aligned}
$$

$$
\begin{aligned}
  \operatorname{FMT_{and}}[A]_k\cdot \operatorname{FMT_{and}}[B]_k &= \left(\sum_{i\supseteq k} A_i\right)\times \left(\sum_{j\supseteq k} B_j\right) \\
  &= \sum_{i\supseteq k}\sum_{j\supseteq k}A_i\times B_j \\
  &= \sum_{i\cap j\supseteq k}A_i\times B_j \\
  &= \operatorname{FMT_{and}}[C]_k
\end{aligned}
$$

### Zeta 变换 & Möbius 反演

这个计算 **子集和** 和 **超集和** 的过程（$g\to f$）称为 **Zeta 变换**。

$$
f_0(S)=\sum_{T\subseteq S}g_0(T)
$$

$$
f_1(S)=\sum_{T\supseteq S}g_1(T)
$$

而 Zeta 的逆变换（$f\to g$）称为 **Möbius 反演**。

$$
g_0(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}f_0(T)
$$

$$
g_1(S)=\sum_{T\supseteq S}(-1)^{|T|-|S|}f_1(T)
$$

可以利用容斥原理证明（超集同理）：

$$
\begin{aligned}
  \sum_{T\subseteq S}(-1)^{|S|-|T|}f_0(T) &= \sum_{T\subseteq S}(-1)^{|S|-|T|}\sum_{U\subseteq T}g_0(U) \\
  &= \sum_{U\subseteq S}g_0(U)\sum_{U\subseteq T\subseteq S}(-1)^{|S|-|T|} \\
  &= \sum_{U\subseteq S}g_0(U)\sum_{k=0}^{|S|-|U|}(-1)^k\binom{|S|-|U|}{k} \\
  &= \sum_{U\subseteq S}g_0(U)[U=S] \\
  &= g_0(S)
\end{aligned}
$$

接下来考虑如何计算 Zeta 变换和 Möbius 反演。

### 分治 & 倍增

#### Zeta 变换

直接枚举的时间复杂度为 $O(n^2)$，效率太低。类似 FFT，我们可以考虑分治。

我们令序列 $A$ 的前一半为 $A_0$，后一半为 $A_1$。不难发现 $A_0$ 最高位都为 $0$，$A_1$ 的最高位都为 $1$。

那么，$A_0$ 的子集就是他本身的子集，而 $A_1$ 满足条件的子集是他本身和 $A_0$ 的子集：

$$
\operatorname{FMT_{or}}[A]=\operatorname{merge}(\operatorname{FMT_{or}}[A_0],\operatorname{FMT_{or}}[A_1]+\operatorname{FMT_{or}}[A_0])
$$

同理，$A_1$ 的超集就是他本身的超集，而 $A_0$ 满足条件的超集是他本身和 $A_1$ 的超集：

$$
\operatorname{FMT_{and}}[A]=\operatorname{merge}(\operatorname{FMT_{and}}[A_0]+\operatorname{FMT_{and}}[A_1],\operatorname{FMT_{and}}[A_1])
$$

其中，$\operatorname{merge}$ 表示将两个序列像字符串拼接一样首尾相连，加号（$+$）就是直接按位相加。

这样我们就能在 $O(n\log{n})$ 的时间复杂度得到了 $\operatorname{FMT_{or}}[A]$ 和 $\operatorname{FMT_{and}}[A]$。

#### Möbius 反演

既然 $A_0$ 的子集是他本身，$A_1$ 的子集是 $\operatorname{FMT}[A_1]+\operatorname{FMT}[A_0]$，很容易得出反演的递推式：

$$
\operatorname{UFMT_{or}}[A]=\operatorname{merge}(\operatorname{UFMT_{or}}[A_0],\operatorname{UFMT_{or}}[A_1]-\operatorname{UFMT_{or}}[A_0])
$$

既然 $A_1$ 的超集是他本身，$A_0$ 的超集是 $\operatorname{FMT}[A_0]+\operatorname{FMT}[A_1]$，很容易得出反演的递推式：

$$
\operatorname{UFMT_{and}}[A]=\operatorname{merge}(\operatorname{UFMT_{and}}[A_0]-\operatorname{UFMT_{and}}[A_1],\operatorname{UFMT_{and}}[A_1])
$$

#### 分治实现

容易发现正变换和逆变换可以合并为一个函数。正变换 $\text{type}=1$，逆变换 $\text{type}=-1$。

$$
\operatorname{T_{or}}[A]=\operatorname{merge}(\operatorname{T_{or}}[A_0],\operatorname{T_{or}}[A_1]+\operatorname{T_{or}}[A_0]\times\text{type})
$$

$$
\operatorname{T_{and}}[A]=\operatorname{merge}(\operatorname{T_{and}}[A_0]+\operatorname{T_{and}}[A_1]\times\text{type},\operatorname{T_{and}}[A_1])
$$

综上，我们可以通过 **分治** 写出 `fmt_or` 和 `fmt_and` 的递归版本：

```cpp
void fmt_or(ll *a,int n,int type)
{
	if(n==1)return;
	int mid=n>>1;
	ll *a0=a,*a1=a+mid;
	fmt_or(a0,mid,type);
	fmt_or(a1,mid,type);
	for(int i=0;i<mid;i++)a1[i]=(a1[i]+a0[i]*type+mod)%mod;
}
```

```cpp
void fmt_and(ll *a,int n,int type)
{
	if(n==1)return;
	int mid=n>>1;
	ll *a0=a,*a1=a+mid;
	fmt_and(a0,mid,type);
	fmt_and(a1,mid,type);
	for(int i=0;i<mid;i++)a0[i]=(a0[i]+a1[i]*type+mod)%mod;
}
```

#### 倍增实现

类似 FFT，我们可以通过 **倍增** 写出 `fmt_or` 和 `fmt_and` 更高效（常数更小）的迭代版本：

```cpp
void fmt_or(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				a[i+j+k]=(a[i+j+k]+a[i+j]*type+mod)%mod;
			}
		}
	}
}
```

```cpp
void fmt_and(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				a[i+j]=(a[i+j]+a[i+j+k]*type+mod)%mod;
			}
		}
	}
}
```

### 高维前缀和

#### 前缀和

一维序列 $A$ 的前缀和 $S$ 相当于序号小于等于它的所有元素之和。

$$
S_i=\sum_{j=1}^i A_j
$$

#### 高维前缀和

扩展到 **高维前缀和**（K-Dimensional Prefix Sum），就是各维度的索引都小于或等于它的所有元素之和。假设有 $k$ 个维度，每个维度的索引范围为 $n$。

$$
S_{i_1,\cdots,i_k}=\sum_{j_1\le i_1,\cdots,j_k\le i_k}A_{j_1,\cdots,j_k}
$$

#### 容斥原理

根据容斥原理，可以列出：

$$
S_{i_1,\cdots,i_k}=\sum_{T\subseteq \{1,\cdots,k\}}(-1)^{|T|}S_T
$$

但这个方法的时间复杂度为 $O(2^kn^k)$，效率太低。

#### 逐维前缀和

注意到，$k$ 维前缀和就等于 $k$ 次求和：

$$
S_{i_1,\cdots,i_k}=\sum_{j_1\le i_1,\cdots,j_k\le i_k}A_{j_1,\cdots,j_k}=\sum_{j_1\le i_1}\cdots\sum_{j_k\le i_k} A_{j_1,\cdots,j_k}
$$

所以，一个显然的算法是，每次只考虑一个维度，固定所有其它维度，然后求若干个一维前缀和，这样对所有 $k$ 个维度分别求和之后，得到的就是 $k$ 维前缀和。

这个方法的时间复杂度为 $O(kn^k)$。

#### Zeta 变换

当每维只有 $0/1$ 两种序号时，高维前缀和就是子集和。

同理，也可以通过 **高维后缀和**（K-Dimensional Suffix Sum）求出超集和。

所以，我们可以通过高维前缀和求出 Zeta 变换。

#### Möbius 反演

类似地，我们可以通过高维差分求出 Möbius 反演。

#### 代码实现

我们可以写出 `fmt_or` 和 `fmt_and` 的高维前缀和版本：

```cpp
void pfs_or(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(i&j)a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
```

```cpp
void sfs_and(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(!(i&j))a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
```

## 快速沃尔什变换（FWT）

### 分治实现

```cpp
void fwt_xor(ll *a,int n,int type)
{
	if(n==1)return;
	int mid=n>>1;
	ll *a0=a,*a1=a+mid;
	fwt_xor(a0,mid,type);
	fwt_xor(a1,mid,type);
	for(int i=0;i<mid;i++)
	{
		ll x=a0[i],y=a1[i],t=type==1?1:mod+1>>1;
		a0[i]=(x+y)*t%mod;
		a1[i]=(x-y+mod)*t%mod;
	}
}
```

### 倍增实现

```cpp
void fwt_xor(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				ll x=a[i+j],y=a[i+j+k],t=type==1?1:mod+1>>1;
				a[i+j]=(x+y)*t%mod;
				a[i+j+k]=(x-y+mod)*t%mod;
			}
		}
	}
}
```

## 性能分析

- 测试机器：CPU Apple M3 Max，RAM 36GB
- 测试环境：macOS Sequoia 15.6，clang 17.0.0
- 编译选项：`-std=c++17 -O2`
- 计时方法：`std::chrono::high_resolution_clock`
- 测试方法：每个算法连续运行 $100$ 次，记录耗时并计算平均值
- 数据规模：每次 $2^{24}=16777216\approx 1.68\times 10^7$ 个随机整数

|    算法    | 或卷积（$\operatorname{or}$） | 与卷积（$\operatorname{and}$） | 异或卷积（$\operatorname{xor}$） | 同或卷积（$\operatorname{xnor}$） |
| :--------: | :---------------------------: | :----------------------------: | :------------------------------: | :-------------------------------: |
|  分治递归  |      $665.67\mathrm{ms}$      |      $693.12\mathrm{ms}$       |       $1167.31\mathrm{ms}$       |       $1164.39\mathrm{ms}$        |
|  倍增迭代  |      $575.31\mathrm{ms}$      |      $559.65\mathrm{ms}$       |       $939.02\mathrm{ms}$        |        $937.16\mathrm{ms}$        |
| 高维前缀和 |      $966.18\mathrm{ms}$      |      $961.38\mathrm{ms}$       |                -                 |                 -                 |

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
const int mod=998244353;
const int N=20;
void fmt_or(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				a[i+j+k]=(a[i+j+k]+a[i+j]*type+mod)%mod;
			}
		}
	}
}
void fmt_and(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				a[i+j]=(a[i+j]+a[i+j+k]*type+mod)%mod;
			}
		}
	}
}
void fwt_xor(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				ll x=a[i+j],y=a[i+j+k],t=type==1?1:mod+1>>1;
				a[i+j]=(x+y)*t%mod;
				a[i+j+k]=(x-y+mod)*t%mod;
			}
		}
	}
}
ll A[1<<N],B[1<<N],a[1<<N],b[1<<N];
template<typename F>
void calc(F f,int n)
{
	for(int i=0;i<n;i++){a[i]=A[i];b[i]=B[i];}
	f(a,n,1);
	f(b,n,1);
	for(int i=0;i<n;i++)a[i]=a[i]*b[i]%mod;
	f(a,n,-1);
	for(int i=0;i<n;i++)cout<<a[i]<<' ';
	cout<<'\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin>>n;
	n=1<<n;
	for(int i=0;i<n;i++)cin>>A[i];
	for(int i=0;i<n;i++)cin>>B[i];
	calc(fmt_or,n);
	calc(fmt_and,n);
	calc(fwt_xor,n);
	return 0;
}
```
