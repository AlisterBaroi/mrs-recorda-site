---
title: '题解：P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)'
date: 2025-08-06T19:00
authors: [lailai]
tags: [solution, luogu]
---

## 原题链接

- [洛谷 P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)](https://www.luogu.com.cn/problem/P4717)

<!-- truncate -->

## 题意简述

给定长度为 $2^n$ 的两个序列 $A,B$，设：

$$
C_k=\sum_{i\oplus j=k}A_i\times B_j
$$

分别当 $\oplus$ 是 $\operatorname{or},\operatorname{and},\operatorname{xor}$ 时求出 $C$。

## 解题思路

### 引入

快速傅立叶变换（Fast Fourier Transform，FFT）可以 $O(n\log n)$ 计算 **加法卷积**（多项式乘法）：

$$
C_k=\sum_{i+j=k}A_i\times B_j
$$

如果将求和符号的 **加法**（$+$）替换为 **位运算**（$\operatorname{or},\operatorname{and},\operatorname{xor}$），变成 **位运算卷积** 该如何处理呢？

直接枚举的时间复杂度为 $O(n^2)$，效率太低，因此需要使用 FMT 和 FWT。

### 简介

快速莫比乌斯变换（Fast Möbius Transform，FMT）可以 $O(n\log n)$ 计算 **或卷积** 和 **与卷积**：

$$
C_k=\sum_{i\operatorname{or} j=k}A_i\times B_j
$$

$$
C_k=\sum_{i\operatorname{and} j=k}A_i\times B_j
$$

快速沃尔什变换（Fast Walsh Transform，FWT）可以 $O(n\log n)$ 计算 **异或卷积**：

$$
C_k=\sum_{i\operatorname{xor} j=k}A_i\times B_j
$$

有些地方会将 FMT 和 FWT 统称为 FWT。

### 思想

与 FFT 类似，首先 $O(n\log n)$ 进行 **正变换**：

$$
A\xrightarrow{\text{FMT/FWT}}\operatorname{FMT/FWT}[A]
$$

$$
B\xrightarrow{\text{FMT/FWT}}\operatorname{FMT/FWT}[B]
$$

然后 $O(n)$ **逐位相乘**（点积）：

$$
\operatorname{FMT/FWT}[C]=\operatorname{FMT/FWT}[A]\cdot\operatorname{FMT/FWT}[B]
$$

最后 $O(n\log n)$ 通过 **逆变换** 得到结果：

$$
C\xleftarrow{\text{IFMT/IFWT}}\operatorname{FMT/FWT}[C]
$$

接下来，考虑如何构造变换规则。

### 快速莫比乌斯变换（FMT）

如果有 $i\operatorname{or} j=k$，那么 $i$ 的二进制位为 $1$ 的位置和 $j$ 的二进制位为 $1$ 的位置肯定是 $k$ 的二进制位为 $1$ 的位置的子集。

$$
C_k=\sum_{i\operatorname{or} j=k}A_i\times B_j
$$

显然可以构造：

$$
\operatorname{FMT}[A]_k=\sum_{i\subseteq k}A_{i}
$$

### Zeta 变换

### Möbius 变换

### 或卷积（FMT_OR）

那么：

$$
\begin{aligned}
  \operatorname{FWT}[A]_k\cdot \operatorname{FWT}[B]_k &= \left(\sum_{i\subseteq k} A_i\right)\times \left(\sum_{j\subseteq k} B_j\right) \\
  &= \sum_{i\subseteq k}\sum_{j\subseteq k}A_i\times B_j \\
  &= \sum_{i\cup j\subseteq k}A_i\times B_j \\
  &= \operatorname{FWT}[C]_k
\end{aligned}
$$

接下来考虑 $FWT[A]$ 怎么求。

首先肯定不能枚举了，复杂度为 $O(n^2)$。既然不能整体枚举，我们就考虑分治。

我们把整个区间二分，其实二分区间之后，下标写成二进制形式是有规律可循的。

我们令 $A_0$ 表示 $A$ 的前一半，$A_1$ 表示区间的后一半，那么 $A_0$ 就是 A 下标最大值的最高位为 $0$，他的子集就是他本身的子集（因为最高位为 $0$ 了），但是 $A_1$ 的最高位是 $1$，他满足条件的子集不仅仅是他本身，还包最高位为 $0$ 的子集，即

$$
FWT[A] = merge(FWT[A_0], FWT[A_0] + FWT[A_1])
$$

其中 merge 表示像字符串拼接一样把两个数组拼起来，$+$ 就是普通加法，表示对应二进制位相加。

这样我们就通过二分能在 $O(\log{n})$ 的时间复杂度内完成拼接，每次拼接的时候要完成一次运算，也就是说在 $O(n\log{n})$ 的时间复杂度得到了 $FWT[A]$。

接下来就是反演了，其实反演是很简单的，既然知道了 $A_0$ 的本身的子集是他自己（$A_0 = FWT[A_0]$），$A_1$ 的子集是 $FWT[A_0] + FWT[A_1]$，那就很简单的得出反演的递推式了：

$$
UFWT[A'] = merge(UFWT[A_0'], UFWT[A_1'] - UFWT[A_0'])
$$

容易发现顺变换和逆变换可以合并为一个函数。

#### 递归

```cpp
void fmt_or(ll *a,int n,int type)
{
	if(n==1)return;
	int mid=n>>1;
	fmt_or(a,mid,type);
	fmt_or(a+mid,mid,type);
	for(int i=0;i<mid;i++)
	{
		a[mid+i]=(a[mid+i]+a[i]*type+mod)%mod;
	}
}
```

#### 迭代

```cpp
void fmt_or(ll *a,int n,int type)
{
	for(ll x=2;x<=n;x<<=1)
	{
		ll k=x>>1;
		for(ll i=0;i<n;i+=x)
		{
			for(ll j=0;j<k;j++)
			{
				a[i+j+k]=(a[i+j+k]+a[i+j]*type+mod)%mod;
			}
		}
	}
}
```

#### 优化

```cpp
void fmt_or(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(i&j)a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
```

### 与卷积（AND）

$$
C_k=\sum_{i\operatorname{and} j=k}A_i\times B_j
$$

### 异或卷积（XOR）

$$
C_k=\sum_{i\operatorname{xor} j=k}A_i\times B_j
$$

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
const int mod=998244353;
const int N=1<<20;
void fmt_or(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(i&j)a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
void fmt_and(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(!(i&j))a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
void fwt_xor(ll *a,int n,int type)
{
	type=type==1?1:mod+1>>1;
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				ll x=a[i+j],y=a[i+j+k];
				a[i+j]=(x+y)*type%mod;
				a[i+j+k]=(x-y+mod)*type%mod;
			}
		}
	}
}
ll A[N],B[N],a[N],b[N];
template<typename F>
void calc(F f,int n)
{
	for(int i=0;i<n;i++){a[i]=A[i];b[i]=B[i];}
	f(a,n,1);
	f(b,n,1);
	for(int i=0;i<n;i++)a[i]=a[i]*b[i]%mod;
	f(a,n,-1);
	for(int i=0;i<n;i++)cout<<a[i]<<' ';
	cout<<'\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin>>n;
	n=1<<n;
	for(int i=0;i<n;i++)cin>>A[i];
	for(int i=0;i<n;i++)cin>>B[i];
	calc(fmt_or,n);
	calc(fmt_and,n);
	calc(fwt_xor,n);
	return 0;
}
```
