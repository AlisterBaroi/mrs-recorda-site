---
title: '题解：P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)'
date: 2025-08-06T19:00
authors: [lailai]
tags: [solution, luogu]
---

## 原题链接

- [洛谷 P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)](https://www.luogu.com.cn/problem/P4717)

<!-- truncate -->

## 参考资料

- [快速沃尔什变换 - OI Wiki](https://oi-wiki.org/math/poly/fwt/)
- [容斥原理 - OI Wiki](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)
- [前缀和 & 差分 - OI Wiki](https://oi-wiki.org/basic/prefix-sum/)
- [容斥原理与子集卷积（四） - 好地方bug - 知乎](https://zhuanlan.zhihu.com/p/33328788)
- [FMT（快速莫比乌斯变换） - 秋钧 - 知乎](https://zhuanlan.zhihu.com/p/672965753)
- [FWT(快速沃尔什变换)零基础详解qaq（ACM/OI） - 月下桃子树 - 知乎](https://zhuanlan.zhihu.com/p/41867199)
- [Fast Walsh–Hadamard transform - Wikipedia](https://en.wikipedia.org/wiki/Fast_Walsh–Hadamard_transform)
- [Prefix sum - Wikipedia](https://en.wikipedia.org/wiki/Prefix_sum)
- [P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT) 题解 - 洛谷](https://www.luogu.com.cn/problem/solution/P4717)

## 题意简述

给定长度为 $2^n$ 的两个序列 $A,B$，设：

$$
C_k=\sum_{i\oplus j=k}A_i\times B_j
$$

分别当 $\oplus$ 是 $\operatorname{or},\operatorname{and},\operatorname{xor}$ 时求出 $C$。

## 解题思路

### 说明

为避免歧义，我们统一数据规模的表示方法：

$$
n\gets 2^n
$$

### 引入

**快速傅立叶变换**（FFT，Fast Fourier Transform）可以 $O(n\log n)$ 计算 **加法卷积**（多项式乘法）：

$$
C_k=\sum_{i+j=k}A_i\times B_j
$$

如果将求和符号的 **加法**（$+$）替换为 **位运算**（$\operatorname{or},\operatorname{and},\operatorname{xor}$），变成 **位运算卷积** 该如何处理呢？

直接枚举的时间复杂度为 $O(n^2)$，效率太低，因此需要使用 FMT 和 FWT。

### 简介

**快速莫比乌斯变换**（FMT，Fast Möbius Transform）可以 $O(n\log n)$ 计算 **或卷积** 和 **与卷积**：

$$
C_k=\sum_{i\operatorname{or} j=k}A_i\times B_j
$$

$$
C_k=\sum_{i\operatorname{and} j=k}A_i\times B_j
$$

**快速沃尔什变换**（FWT，Fast Walsh Transform）可以 $O(n\log n)$ 计算 **异或卷积** 和 **同或卷积**：

$$
C_k=\sum_{i\operatorname{xor} j=k}A_i\times B_j
$$

$$
C_k=\sum_{i\operatorname{xnor} j=k}A_i\times B_j
$$

有些地方会将 FMT 和 FWT 统称为 FWT。

### 思想

FMT 和 FWT 的整体思想类似 FFT。

首先 $O(n\log n)$ 进行 **正变换**：

$$
A\xrightarrow{\text{FMT/FWT}}A'
$$

$$
B\xrightarrow{\text{FMT/FWT}}B'
$$

然后 $O(n)$ **逐位相乘**（点积）：

$$
C'=A'\cdot B'
$$

最后 $O(n\log n)$ 通过 **逆变换** 得到结果：

$$
C'\xrightarrow{\text{IFMT/IFWT}}C
$$

## 前置知识

### 位运算 & 集合

每个二进制数可以看作一个 **集合**，其中二进制位为 $1$ 的位置表示对应元素属于集合。

$$
(10010110)_2\iff \{a_1,a_2,a_4,a_7\}
$$

两个数的 **按位或** 运算相当于两个集合的 **并集**，而 **按位与** 运算相当于 **交集**。

$$
0101\operatorname{or}1100=1101\iff \{a_0,a_2\}\cup\{a_2,a_3\}=\{a_0,a_2,a_3\}
$$

$$
0101\operatorname{and}1100=0100\iff \{a_0,a_2\}\cap\{a_2,a_3\}=\{a_2\}
$$

而超集就是补集的子集的补集，本质上就是把 $0/1$ 取反，所以子集和超集是 **对称** 的。

$$
T\supseteq S\iff \overline{T}\subseteq \overline{S}
$$

### 变换 & 反演

**变换**（Transform）是按照一定规则，把一个对象（数、向量、函数、图形等）映射成另一个对象的过程。

$$
f\to g
$$

变换的逆运算称为 **逆变换**，也叫做 **反演**（Inversion）。

$$
g\to f
$$

在数学和算法中，我们会遇到许多变换，例如傅里叶变换、数论变换、莫比乌斯变换和沃尔什变换等。

在这里，我解释一下各种变换的命名方式。

不带“快速”前缀的名称，指的是变换本身，并不涉及具体的实现方法。

而带“快速”前缀的名称，则表示使用一种高效实现该变换的算法。

### Zeta 变换

以下两个式子为 **子集和**（Sum Over Subsets）和 **超集和**（Sum Over Supersets）。

$$
f_0(S)=\sum_{T\subseteq S}g_0(T)
$$

$$
f_1(S)=\sum_{T\supseteq S}g_1(T)
$$

计算 **子集和** 和 **超集和** 的过程（$g\to f$）称为 **Zeta 变换**（Zeta Transform）。

### 莫比乌斯反演

而 Zeta 的逆变换（$f\to g$）称为 **莫比乌斯反演**（Möbius Inversion）。

$$
g_0(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}f_0(T)
$$

$$
g_1(S)=\sum_{T\supseteq S}(-1)^{|T|-|S|}f_1(T)
$$

可以利用 **容斥原理** 证明（超集同理）：

$$
\begin{aligned}
  \sum_{T\subseteq S}(-1)^{|S|-|T|}f_0(T) &= \sum_{T\subseteq S}(-1)^{|S|-|T|}\sum_{U\subseteq T}g_0(U) \\
  &= \sum_{U\subseteq S}g_0(U)\sum_{U\subseteq T\subseteq S}(-1)^{|S|-|T|} \\
  &= \sum_{U\subseteq S}g_0(U)\sum_{k=0}^{|S|-|U|}(-1)^k\binom{|S|-|U|}{k} \\
  &= \sum_{U\subseteq S}g_0(U)[U=S] \\
  &= g_0(S)
\end{aligned}
$$

莫比乌斯反演在其他数学和算法领域中也有出现，例如 [数论中的莫比乌斯反演](https://oi-wiki.org/math/number-theory/mobius/) 等。

共同点都是在某种偏序结构上把累加关系反过来，恢复原函数。

## 快速莫比乌斯变换（FMT）

### 原理

接下来考虑如何构造变换规则。

如果 $i\operatorname{or}/\operatorname{and} j=k$，即 $i$ 和 $j$ 的并集/交集为 $k$，那么 $i$ 和 $j$ 必定是 $k$ 的子集/超集。

$$
i\operatorname{or} j=k\Rightarrow i\subseteq k\land j\subseteq k
$$

$$
i\operatorname{and} j=k\Rightarrow i\supseteq k\land j\supseteq k
$$

我们可以构造：

$$
\operatorname{FMT_{or}}[A]_k=\sum_{i\subseteq k}A_{i}
$$

$$
\operatorname{FMT_{and}}[A]_k=\sum_{i\supseteq k}A_{i}
$$

那么：

$$
\begin{aligned}
  \operatorname{FMT_{or}}[A]_k\cdot \operatorname{FMT_{or}}[B]_k &= \left(\sum_{i\subseteq k} A_i\right)\times \left(\sum_{j\subseteq k} B_j\right) \\
  &= \sum_{i\subseteq k}\sum_{j\subseteq k}A_i\times B_j \\
  &= \sum_{i\cup j\subseteq k}A_i\times B_j \\
  &= \operatorname{FMT_{or}}[C]_k
\end{aligned}
$$

$$
\begin{aligned}
  \operatorname{FMT_{and}}[A]_k\cdot \operatorname{FMT_{and}}[B]_k &= \left(\sum_{i\supseteq k} A_i\right)\times \left(\sum_{j\supseteq k} B_j\right) \\
  &= \sum_{i\supseteq k}\sum_{j\supseteq k}A_i\times B_j \\
  &= \sum_{i\cap j\supseteq k}A_i\times B_j \\
  &= \operatorname{FMT_{and}}[C]_k
\end{aligned}
$$

而这两个式子就是 **子集和** 和 **超集和**。

### 分治

#### 正变换

接下来考虑如何计算 Zeta 变换和莫比乌斯反演。

直接枚举的时间复杂度为 $O(n^2)$，效率太低。类似 FFT，我们可以考虑分治。

我们令序列 $A$ 的前一半为 $A_0$，后一半为 $A_1$。不难发现 $A_0$ 最高位都为 $0$，$A_1$ 的最高位都为 $1$。

那么，$A_0$ 的子集就是他本身的子集，而 $A_1$ 满足条件的子集是他本身和 $A_0$ 的子集：

$$
\operatorname{FMT_{or}}[A]=\operatorname{merge}(\operatorname{FMT_{or}}[A_0],\operatorname{FMT_{or}}[A_1]+\operatorname{FMT_{or}}[A_0])
$$

同理，$A_1$ 的超集就是他本身的超集，而 $A_0$ 满足条件的超集是他本身和 $A_1$ 的超集：

$$
\operatorname{FMT_{and}}[A]=\operatorname{merge}(\operatorname{FMT_{and}}[A_0]+\operatorname{FMT_{and}}[A_1],\operatorname{FMT_{and}}[A_1])
$$

其中，$\operatorname{merge}$ 表示将两个序列像字符串拼接一样首尾相连，加号（$+$）就是直接按位相加。

这样我们就能在 $O(n\log{n})$ 的时间复杂度得到了 $\operatorname{FMT_{or}}[A]$ 和 $\operatorname{FMT_{and}}[A]$。

#### 逆变换

既然 $A_0$ 的子集是他本身，$A_1$ 的子集是 $\operatorname{FMT}[A_1]+\operatorname{FMT}[A_0]$，很容易得出反演的递推式：

$$
\operatorname{IFMT_{or}}[A]=\operatorname{merge}(\operatorname{IFMT_{or}}[A_0],\operatorname{IFMT_{or}}[A_1]-\operatorname{IFMT_{or}}[A_0])
$$

既然 $A_1$ 的超集是他本身，$A_0$ 的超集是 $\operatorname{FMT}[A_0]+\operatorname{FMT}[A_1]$，很容易得出反演的递推式：

$$
\operatorname{IFMT_{and}}[A]=\operatorname{merge}(\operatorname{IFMT_{and}}[A_0]-\operatorname{IFMT_{and}}[A_1],\operatorname{IFMT_{and}}[A_1])
$$

#### 代码实现

容易发现正变换和逆变换可以合并为一个函数。正变换 $\text{type}=1$，逆变换 $\text{type}=-1$。

$$
\operatorname{T_{or}}[A]=\operatorname{merge}(\operatorname{T_{or}}[A_0],\operatorname{T_{or}}[A_1]+\operatorname{T_{or}}[A_0]\times\text{type})
$$

$$
\operatorname{T_{and}}[A]=\operatorname{merge}(\operatorname{T_{and}}[A_0]+\operatorname{T_{and}}[A_1]\times\text{type},\operatorname{T_{and}}[A_1])
$$

综上，我们可以通过分治写出 $\operatorname{or}$ 和 $\operatorname{and}$ 的递归版本：

```cpp
void fmt_or(ll *a,int n,int type)
{
	if(n==1)return;
	int mid=n>>1;
	ll *a0=a,*a1=a+mid;
	fmt_or(a0,mid,type);
	fmt_or(a1,mid,type);
	for(int i=0;i<mid;i++)a1[i]=(a1[i]+a0[i]*type+mod)%mod;
}
```

```cpp
void fmt_and(ll *a,int n,int type)
{
	if(n==1)return;
	int mid=n>>1;
	ll *a0=a,*a1=a+mid;
	fmt_and(a0,mid,type);
	fmt_and(a1,mid,type);
	for(int i=0;i<mid;i++)a0[i]=(a0[i]+a1[i]*type+mod)%mod;
}
```

### 倍增

类似 FFT，我们可以通过倍增写出 $\operatorname{or}$ 和 $\operatorname{and}$ 更高效（常数更小）的迭代版本：

```cpp
void fmt_or(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				a[i+j+k]=(a[i+j+k]+a[i+j]*type+mod)%mod;
			}
		}
	}
}
```

```cpp
void fmt_and(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				a[i+j]=(a[i+j]+a[i+j+k]*type+mod)%mod;
			}
		}
	}
}
```

### 高维前缀和

#### 前缀和

一维序列 $A$ 的前缀和 $S$ 相当于序号小于等于它的所有元素之和。

$$
S_i=\sum_{j=1}^i A_j
$$

#### 高维前缀和

扩展到 **高维前缀和**（K-Dimensional Prefix Sum），就是各维度的索引都小于或等于它的所有元素之和。假设有 $k$ 个维度，每个维度的索引范围为 $n$。

$$
S_{i_1,\cdots,i_k}=\sum_{j_1\le i_1,\cdots,j_k\le i_k}A_{j_1,\cdots,j_k}
$$

#### 容斥原理

根据容斥原理，可以列出：

$$
S_{i_1,\cdots,i_k}=\sum_{T\subseteq \{1,\cdots,k\}}(-1)^{|T|}S_T
$$

但这个方法的时间复杂度为 $O(2^kn^k)$，效率太低。

#### 逐维前缀和

注意到，$k$ 维前缀和就等于 $k$ 次求和：

$$
S_{i_1,\cdots,i_k}=\sum_{j_1\le i_1,\cdots,j_k\le i_k}A_{j_1,\cdots,j_k}=\sum_{j_1\le i_1}\cdots\sum_{j_k\le i_k} A_{j_1,\cdots,j_k}
$$

所以，一个显然的算法是，每次只考虑一个维度，固定所有其它维度，然后求若干个一维前缀和，这样对所有 $k$ 个维度分别求和之后，得到的就是 $k$ 维前缀和。

这个方法的时间复杂度为 $O(kn^k)$。

#### 正变换

当每维只有 $0/1$ 两种序号时，高维前缀和就是子集和。

同理，也可以通过 **高维后缀和**（K-Dimensional Suffix Sum）求出超集和。

所以，我们可以通过高维前缀和求出 Zeta 变换。

#### 逆变换

类似地，我们可以通过高维差分求出莫比乌斯反演。

#### 代码实现

我们可以写出 $\operatorname{or}$ 和 $\operatorname{and}$ 的高维前缀和版本：

```cpp
void pfs_or(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(i&j)a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
```

```cpp
void sfs_and(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(!(i&j))a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
```

### 子集卷积

FMT 还可以计算 **子集卷积**：

$$
C_k=\sum_{\substack{i\operatorname{or} j=k\\i\operatorname{and} j=0}}A_i\times B_j
$$

第一个限制 $i\operatorname{or} j=k$，很容易处理，直接用与卷积即可。

$$
(A*B)_k=\sum_{i\operatorname{and} j=k}A_i\times B_j
$$

第二个限制 $i\operatorname{and} j=0$，也就是没有相同元素，所以：

$$
i\operatorname{and} j=0\iff |i|+|j|=|i\operatorname{or} j|
$$

我们可以多开一个维度，记录集合中的元素个数。具体地，令：

$$
F_{i,j}=\begin{cases}
  A_j & |j|=i \\
  0 & |j|\neq i
\end{cases},
G_{i,j}=\begin{cases}
  B_j & |j|=i \\
  0 & |j|\neq i
\end{cases}
$$

再做一个卷积：

$$
H_{i,j}=\sum_{k=1}^i(F_{k}*G_{i-k})_j
$$

答案为：

$$
C_i=H_{|i|,i}
$$

时间复杂度为 $O(n^22^n)$。

- 详见 [洛谷 P6097 【模板】子集卷积](https://www.luogu.com.cn/problem/P6097)

## 快速沃尔什变换（FWT）

### 原理

接下来考虑构造异或运算。

如果我们令 $i\circ j$ 表示 $i\cap j$ 中 $1$ 数量的奇偶性，即：

$$
i\circ j=\operatorname{popcount}(i\cap j)\bmod 2
$$

其中 $\operatorname{popcount}(x)$ 表示 $x$ 二进制下 $1$ 的个数。

那么容易有：

$$
(i\circ k)\oplus (j\circ k)=(i\oplus j)\circ k
$$

我们可以构造：

$$
\operatorname{FWT_{xor}}[A]_k=\sum_{i\circ k=0}A_i-\sum_{i\circ k=1}A_i
$$

$$
\operatorname{FWT_{xnor}}[A]_k=\sum_{i\circ k=1}A_i-\sum_{i\circ k=0}A_i
$$

那么：

$$
\begin{aligned}
  \operatorname{FWT_{xor}}[A]_k\cdot \operatorname{FWT_{xor}}[B]_k &= \left(\sum_{i\circ k=0}A_i-\sum_{i\circ k=1}A_i\right)\times\left(\sum_{j\circ k=0}B_j-\sum_{j\circ k=1}B_j\right) \\
  &= \left(\sum_{i\circ k=0}A_i\sum_{j\circ k=0}B_j+\sum_{i\circ k=1}A_i\sum_{j\circ k=1}B_j\right) \\
  &- \left(\sum_{i\circ k=0}A_i\sum_{j\circ k=1}B_j+\sum_{i\circ k=1}A_i\sum_{j\circ k=0}B_j\right) \\
  &= \sum_{(i\oplus j)\circ k=0}A_iB_j-\sum_{(i\oplus j)\circ k=1}A_iB_j \\
  &= \operatorname{FWT_{xor}}[C]_k
\end{aligned}
$$

### 分治

#### 正变换

对于 $i$ 在当前位为 $0$ 的子数列 $FWT[A_0]$，进行 $\circ$ 运算时发现它和 $0$ 计算或和 $1$ 计算结果都不会变（因为 $0\cap 0=0,0\cap1=0$），所以 $FWT[A]=\sum_{i\circ j=0}A_j-\sum_{i\circ j=1}A_j$ 中的 $\sum_{i\circ j=1}A_j=0$。

对于 $i$ 在当前位为 $1$ 的子数列 $A_1$，进行 $\circ$ 运算时发现它和 $0$ 计算结果是 $0$，和 $1$ 计算结果是 $1$（因为 $1\cap 0=0,1\cap1=1$）。

综上，有：

$$
\operatorname{FWT_{xor}}[A]=\operatorname{merge}(\operatorname{FWT_{xor}}[A_0]+\operatorname{FWT_{xor}}[A_1],\operatorname{FWT_{xor}}[A_0]-\operatorname{FWT_{xor}}[A_1])
$$

$$
\operatorname{FWT_{xnor}}[A]=\operatorname{merge}(\operatorname{FWT_{xnor}}[A_0]-\operatorname{FWT_{xnor}}[A_1],\operatorname{FWT_{xnor}}[A_0]+\operatorname{FWT_{xnor}}[A_1])
$$

#### 逆变换

逆变换易得：

$$
\operatorname{IFWT_{xor}}[A]=\operatorname{merge}\left(\frac{\operatorname{IFWT_{xor}}[A_0]+\operatorname{IFWT_{xor}}[A_1]}{2},\frac{\operatorname{IFWT_{xor}}[A_0]-\operatorname{IFWT_{xor}}[A_1]}{2}\right)
$$

$$
\operatorname{IFWT_{xnor}}[A]=\operatorname{merge}\left(\frac{\operatorname{IFWT_{xnor}}[A_0]-\operatorname{IFWT_{xnor}}[A_1]}{2},\frac{\operatorname{IFWT_{xnor}}[A_0]+\operatorname{IFWT_{xnor}}[A_1]}{2}\right)
$$

#### 代码实现

容易发现正变换和逆变换可以合并为一个函数。正变换 $\text{type}=1,t=1$，逆变换 $\text{type}=-1,t=\frac{1}{2}$。

$$
\operatorname{T_{xor}}[A]=\operatorname{merge}((\operatorname{T_{xor}}[A_0]+\operatorname{T_{xor}}[A_1])\times t,(\operatorname{T_{xor}}[A_0]-\operatorname{T_{xor}}[A_1])\times t)
$$

$$
\operatorname{T_{xnor}}[A]=\operatorname{merge}((\operatorname{T_{xnor}}[A_0]-\operatorname{T_{xnor}}[A_1])\times t,(\operatorname{T_{xnor}}[A_0]+\operatorname{T_{xnor}}[A_1])\times t)
$$

注意数论中的 $\frac{1}{2}$ 是 $2$ 的逆元，也就是 $\frac{mod+1}{2}$。

综上，我们可以通过分治写出 $\operatorname{xor}$ 和 $\operatorname{xnor}$ 的递归版本：

```cpp
void fwt_xor(ll *a,int n,int type)
{
	if(n==1)return;
	int mid=n>>1;
	ll *a0=a,*a1=a+mid;
	fwt_xor(a0,mid,type);
	fwt_xor(a1,mid,type);
	for(int i=0;i<mid;i++)
	{
		ll x=a0[i],y=a1[i],t=type==1?1:mod+1>>1;
		a0[i]=(x+y)*t%mod;
		a1[i]=(x-y+mod)*t%mod;
	}
}
```

```cpp
void fwt_xnor(ll *a,int n,int type)
{
	if(n==1)return;
	int mid=n>>1;
	ll *a0=a,*a1=a+mid;
	fwt_xnor(a0,mid,type);
	fwt_xnor(a1,mid,type);
	for(int i=0;i<mid;i++)
	{
		ll x=a0[i],y=a1[i],t=type==1?1:mod+1>>1;
		a0[i]=(x-y+mod)*t%mod;
		a1[i]=(x+y)*t%mod;
	}
}
```

### 倍增

同理，我们可以通过倍增写出 $\operatorname{xor}$ 和 $\operatorname{xnor}$ 更高效（常数更小）的迭代版本：

```cpp
void fwt_xor(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				ll x=a[i+j],y=a[i+j+k],t=type==1?1:mod+1>>1;
				a[i+j]=(x+y)*t%mod;
				a[i+j+k]=(x-y+mod)*t%mod;
			}
		}
	}
}
```

```cpp
void fwt_xnor(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				ll x=a[i+j],y=a[i+j+k],t=type==1?1:mod+1>>1;
				a[i+j]=(x-y+mod)*t%mod;
				a[i+j+k]=(x+y)*t%mod;
			}
		}
	}
}
```

## 性能分析

- 测试机器：CPU Apple M3 Max，RAM 36GB
- 测试环境：macOS Sequoia 15.6，clang 17.0.0
- 编译选项：`-std=c++17 -O2`
- 计时方法：调用 `std::chrono::high_resolution_clock`，单位 $\mathrm{ms}$
- 数据生成：调用 `std::mt19937_64` 生成 $2^{24}\approx 1.68\times 10^7$ 个随机整数
- 测试方法：每个算法连续运行 $100$ 次，记录耗时并计算平均值

|             类型/算法             | 倍增迭代 |      分治递归      |    高维前缀和     |
| :-------------------------------: | :------: | :----------------: | :---------------: |
|   或卷积（$\operatorname{or}$）   | $575.31$ | $665.67(+15.7\%)$  | $966.18(+67.9\%)$ |
|  与卷积（$\operatorname{and}$）   | $559.65$ | $693.12(+23.8\%)$  | $961.38(+71.8\%)$ |
| 异或卷积（$\operatorname{xor}$）  | $939.02$ | $1167.31(+24.3\%)$ |   $\text{N/A}$    |
| 同或卷积（$\operatorname{xnor}$） | $937.16$ | $1164.39(+24.2\%)$ |   $\text{N/A}$    |

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
const int mod=998244353;
const int N=20;
void fmt_or(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				a[i+j+k]=(a[i+j+k]+a[i+j]*type+mod)%mod;
			}
		}
	}
}
void fmt_and(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				a[i+j]=(a[i+j]+a[i+j+k]*type+mod)%mod;
			}
		}
	}
}
void fwt_xor(ll *a,int n,int type)
{
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				ll x=a[i+j],y=a[i+j+k],t=type==1?1:mod+1>>1;
				a[i+j]=(x+y)*t%mod;
				a[i+j+k]=(x-y+mod)*t%mod;
			}
		}
	}
}
ll A[1<<N],B[1<<N],a[1<<N],b[1<<N];
template<typename F>
void calc(F f,int n)
{
	for(int i=0;i<n;i++){a[i]=A[i];b[i]=B[i];}
	f(a,n,1);
	f(b,n,1);
	for(int i=0;i<n;i++)a[i]=a[i]*b[i]%mod;
	f(a,n,-1);
	for(int i=0;i<n;i++)cout<<a[i]<<' ';
	cout<<'\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin>>n;
	n=1<<n;
	for(int i=0;i<n;i++)cin>>A[i];
	for(int i=0;i<n;i++)cin>>B[i];
	calc(fmt_or,n);
	calc(fmt_and,n);
	calc(fwt_xor,n);
	return 0;
}
```
