---
title: '题解：P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)'
date: 2025-08-06T19:00
authors: [lailai]
tags: [solution, luogu]
---

## 原题链接

- [洛谷 P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)](https://www.luogu.com.cn/problem/P4717)

<!-- truncate -->

## 题意简述

给定长度为 $2^n$ 的两个序列 $A,B$，设：

$$
C_i=\sum_{j\oplus k = i}A_j \times B_k
$$

分别当 $\oplus$ 是 $\operatorname{or},\operatorname{and},\operatorname{xor}$ 时求出 $C$。

## 解题思路

### 引入

快速傅立叶变换（Fast Fourier Transform，FFT）可以在 $O(n\log n)$ 的时间内求解：

$$
C_k=\sum_{i+j=k}A_i\times B_j
$$

如果将求和符号的 **加法**（$+$）替换为 **位运算**（$\operatorname{or},\operatorname{and},\operatorname{xor}$），该如何处理呢？

直接枚举的时间复杂度为 $O(n^2)$，效率太低，因此需要使用 FMT/FWT。

快速莫比乌斯变换（Fast Möbius Transform，FMT）可以在 $O(n\log n)$ 的时间内求解：

$$
C_k=\sum_{i\operatorname{or} j=k}A_i\times B_j
$$

$$
C_k=\sum_{i\operatorname{and} j=k}A_i\times B_j
$$

快速沃尔什变换（Fast Walsh Transform，FWT）可以在 $O(n\log n)$ 的时间内求解：

$$
C_k=\sum_{i\operatorname{xor} j=k}A_i\times B_j
$$

但有的地方会把 FMT 和 FWT 统称为 FWT。

与 FFT 类似，FMT/FWT 首先进行 **正变换**，然后 **逐位相乘**，最后通过 **逆变换** 得到结果。

接下来，我们要考虑如何构造变换规则。

### OR

$$
C_k=\sum_{i\operatorname{or} j=k}A_i\times B_j
$$

### AND

$$
C_k=\sum_{i\operatorname{and} j=k}A_i\times B_j
$$

### XOR

$$
C_k=\sum_{i\operatorname{xor} j=k}A_i\times B_j
$$

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
const int mod=998244353;
const int N=1<<20;
void fmt_or(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(i&j)a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
void fmt_and(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(!(i&j))a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
void fwt_xor(ll *a,int n,int type)
{
	type=type==1?1:mod+1>>1;
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				ll x=a[i+j],y=a[i+j+k];
				a[i+j]=(x+y)*type%mod;
				a[i+j+k]=(x-y+mod)*type%mod;
			}
		}
	}
}
ll A[N],B[N],a[N],b[N];
template<typename F>
void calc(F f,int n)
{
	for(int i=0;i<n;i++){a[i]=A[i];b[i]=B[i];}
	f(a,n,1);
	f(b,n,1);
	for(int i=0;i<n;i++)a[i]=a[i]*b[i]%mod;
	f(a,n,-1);
	for(int i=0;i<n;i++)cout<<a[i]<<' ';
	cout<<'\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin>>n;
	n=1<<n;
	for(int i=0;i<n;i++)cin>>A[i];
	for(int i=0;i<n;i++)cin>>B[i];
	calc(fmt_or,n);
	calc(fmt_and,n);
	calc(fwt_xor,n);
	return 0;
}
```
