---
title: '题解：P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)'
date: 2025-08-06T19:00
authors: [lailai]
tags: [solution, luogu]
---

## 原题链接

- [洛谷 P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)](https://www.luogu.com.cn/problem/P4717)

<!-- truncate -->

## 参考资料

- [P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT) 题解 - 洛谷](https://www.luogu.com.cn/problem/solution/P4717)
- [快速沃尔什变换 - OI Wiki](https://oi-wiki.org/math/poly/fwt/)
- [容斥原理 - OI Wiki](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)
- [前缀和 & 差分 - OI Wiki](https://oi-wiki.org/basic/prefix-sum/)
- [FMT（快速莫比乌斯变换） - 秋钧 - 知乎](https://zhuanlan.zhihu.com/p/672965753)
- [容斥原理与子集卷积（四） - 好地方bug - 知乎](https://zhuanlan.zhihu.com/p/33328788)
- [Fast Walsh–Hadamard transform - Wikipedia](https://en.wikipedia.org/wiki/Fast_Walsh–Hadamard_transform)
- [Prefix sum - Wikipedia](https://en.wikipedia.org/wiki/Prefix_sum)

## 题意简述

给定长度为 $2^n$ 的两个序列 $A,B$，设：

$$
C_k=\sum_{i\oplus j=k}A_i\times B_j
$$

分别当 $\oplus$ 是 $\operatorname{or},\operatorname{and},\operatorname{xor}$ 时求出 $C$。

## 引入

**快速傅立叶变换**（Fast Fourier Transform，FFT）可以 $O(n\log n)$ 计算 **加法卷积**（多项式乘法）：

$$
C_k=\sum_{i+j=k}A_i\times B_j
$$

如果将求和符号的 **加法**（$+$）替换为 **位运算**（$\operatorname{or},\operatorname{and},\operatorname{xor}$），变成 **位运算卷积** 该如何处理呢？

直接枚举的时间复杂度为 $O(n^2)$，效率太低，因此需要使用 FMT 和 FWT。

## 简介

**快速莫比乌斯变换**（Fast Möbius Transform，FMT）可以 $O(n\log n)$ 计算 **或卷积** 和 **与卷积**：

$$
C_k=\sum_{i\operatorname{or} j=k}A_i\times B_j
$$

$$
C_k=\sum_{i\operatorname{and} j=k}A_i\times B_j
$$

**快速沃尔什变换**（Fast Walsh Transform，FWT）可以 $O(n\log n)$ 计算 **异或卷积**：

$$
C_k=\sum_{i\operatorname{xor} j=k}A_i\times B_j
$$

有些地方会将 FMT 和 FWT 统称为 FWT。

## 思想

类似 FFT，首先 $O(n\log n)$ 进行 **正变换**：

$$
A\xrightarrow{\text{FMT/FWT}}\operatorname{FMT/FWT}[A]
$$

$$
B\xrightarrow{\text{FMT/FWT}}\operatorname{FMT/FWT}[B]
$$

然后 $O(n)$ **逐位相乘**（点积）：

$$
\operatorname{FMT/FWT}[C]=\operatorname{FMT/FWT}[A]\cdot\operatorname{FMT/FWT}[B]
$$

最后 $O(n\log n)$ 通过 **逆变换** 得到结果：

$$
C\xleftarrow{\text{IFMT/IFWT}}\operatorname{FMT/FWT}[C]
$$

接下来，考虑如何构造变换规则。

## 说明

一个二进制数可以看作一个 **集合**，其中二进制位为 $1$ 的位置代表集合中的元素。

两个数的 **按位或运算** 相当于两个集合的 **并集**，而 **按位与运算** 则相当于 **交集**。

而超集就是补集的子集的补集，本质上就是把 $0/1$ 取反，子集和超集是对称的。

$$
T\supseteq S\iff T^c\subseteq S^c
$$

## 快速莫比乌斯变换（FMT）

如果 $i\operatorname{or}/\operatorname{and} j=k$，即 $i$ 和 $j$ 的并集/交集为 $k$，那么 $i$ 和 $j$ 必定是 $k$ 的子集/超集。

$$
i\operatorname{or} j=k\Rightarrow i\subseteq k\land j\subseteq k
$$

$$
i\operatorname{and} j=k\Rightarrow i\supseteq k\land j\supseteq k
$$

我们考虑构造：

$$
\operatorname{FMT_{or}}[A]_k=\sum_{i\subseteq k}A_{i}
$$

$$
\operatorname{FMT_{and}}[A]_k=\sum_{i\supseteq k}A_{i}
$$

那么：

$$
\begin{aligned}
  \operatorname{FMT_{or}}[A]_k\cdot \operatorname{FMT_{or}}[B]_k &= \left(\sum_{i\subseteq k} A_i\right)\times \left(\sum_{j\subseteq k} B_j\right) \\
  &= \sum_{i\subseteq k}\sum_{j\subseteq k}A_i\times B_j \\
  &= \sum_{i\cup j\subseteq k}A_i\times B_j \\
  &= \operatorname{FMT_{or}}[C]_k
\end{aligned}
$$

$$
\begin{aligned}
  \operatorname{FMT_{and}}[A]_k\cdot \operatorname{FMT_{and}}[B]_k &= \left(\sum_{i\supseteq k} A_i\right)\times \left(\sum_{j\supseteq k} B_j\right) \\
  &= \sum_{i\supseteq k}\sum_{j\supseteq k}A_i\times B_j \\
  &= \sum_{i\cup j\supseteq k}A_i\times B_j \\
  &= \operatorname{FMT_{and}}[C]_k
\end{aligned}
$$

## Zeta 变换和 Möbius 反演

这个计算 **子集和**（Sum Over Subsets）和 **超集和**（Sum Over Supersets）的过程称为 **Zeta 变换**。

而 Zeta 的逆变换称为 **Möbius 反演**。

### Zeta 变换

接下来考虑如何计算 Zeta 变换。

直接枚举的时间复杂度为 $O(n^2)$，效率太低。类似 FFT，我们可以考虑分治。

我们把整个区间二分，其实二分区间之后，下标写成二进制形式是有规律可循的。

我们令 $A_0$ 表示 $A$ 的前一半，$A_1$ 表示区间的后一半，那么 $A_0$ 就是 $A$ 下标最大值的最高位为 $0$，他的子集就是他本身的子集（因为最高位为 $0$ 了），但是 $A_1$ 的最高位是 $1$，他满足条件的子集不仅仅是他本身，还包最高位为 $0$ 的子集，即

$$
\operatorname{FMT_{or}}[A]=\operatorname{merge}(\operatorname{FMT_{or}}[A_0],\operatorname{FMT_{or}}[A_1]+\operatorname{FMT}[A_0])
$$

其中 $\operatorname{merge}$ 表示像字符串拼接一样把两个数组拼起来，$+$ 就是普通加法，表示对应二进制位相加。

这样我们就通过二分能在 $O(\log{n})$ 的时间复杂度内完成拼接，每次拼接的时候要完成一次运算，也就是说在 $O(n\log{n})$ 的时间复杂度得到了 $FWT[A]$。

### Möbius 反演

接下来就是 Möbius 反演了。

其实反演是很简单的，既然知道了 $A_0$ 的本身的子集是他自己（$A_0 = FWT[A_0]$），$A_1$ 的子集是 $FWT[A_0] + FWT[A_1]$，那就很简单的得出反演的递推式了：

$$
UFWT[A'] = merge(UFWT[A_0'], UFWT[A_1'] - UFWT[A_0'])
$$

容易发现顺变换和逆变换可以合并为一个函数。正变换时 $\text{type}=1$，逆变换时 $\text{type}=-1$。

$$
T[A'] = merge(T[A_0'], T[A_1'] + T[A_0']\times\text{type})
$$

## 高维前缀和

一维序列 $A$ 的前缀和 $S$ 相当于序号小于等于它的所有元素之和。

$$
S_i=\sum_{j=1}^i A_j
$$

扩展到 **高维前缀和**（K-Dimensional Prefix Sum），就是各维度的索引都小于或等于它的所有元素之和。假设有 $k$ 个维度，每个维度的索引范围为 $n$。

$$
S_{i_1,\cdots,i_k}=\sum_{j_1\le i_1,\cdots,j_k\le i_k}A_{j_1,\cdots,j_k}
$$

计算高维前缀和可以基于 **容斥原理** 或 **逐维前缀和**。

### 容斥原理

基于容斥原理，可以列出：

$$
S_{i_1,\cdots,i_k}=\sum_{T\subseteq \{1,\cdots,k\}}(-1)^{|T|}S_T
$$

但这个方法的时间复杂度为 $O(2^kn^k)$，效率太低。

### 逐维前缀和

$k$ 维前缀和就等于 $k$ 次求和：

$$
S_{i_1,\cdots,i_k}=\sum_{j_1\le i_1,\cdots,j_k\le i_k}A_{j_1,\cdots,j_k}=\sum_{j_1\le i_1}\cdots\sum_{j_k\le i_k} A_{j_1,\cdots,j_k}
$$

所以，一个显然的算法是，每次只考虑一个维度，固定所有其它维度，然后求若干个一维前缀和，这样对所有 $k$ 个维度分别求和之后，得到的就是 $k$ 维前缀和。

这个方法的时间复杂度为 $O(kn^k)$。

### 子集和

当每维只有 $0/1$ 两种序号时，高维前缀和就是子集和。

## 或卷积（FMT_OR）

### 递归

```cpp
void fmt_or(ll *a,int n,int type)
{
	if(n==1)return;
	int mid=n>>1;
	ll *a0=a,*a1=a+mid;
	fmt_or(a0,mid,type);
	fmt_or(a1,mid,type);
	for(int i=0;i<mid;i++)a1[i]=(a1[i]+a0[i]*type+mod)%mod;
}
```

### 迭代

```cpp
void fmt_or(ll *a,int n,int type)
{
	for(ll x=2;x<=n;x<<=1)
	{
		ll k=x>>1;
		for(ll i=0;i<n;i+=x)
		{
			for(ll j=0;j<k;j++)
			{
				a[i+j+k]=(a[i+j+k]+a[i+j]*type+mod)%mod;
			}
		}
	}
}
```

### 优化

```cpp
void fmt_or(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(i&j)a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
```

## 与卷积（AND）

$$
C_k=\sum_{i\operatorname{and} j=k}A_i\times B_j
$$

## 异或卷积（XOR）

$$
C_k=\sum_{i\operatorname{xor} j=k}A_i\times B_j
$$

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
const int mod=998244353;
const int N=1<<20;
void fmt_or(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(i&j)a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
void fmt_and(ll *a,int n,int type)
{
	for(int i=1;i<n;i<<=1)
	{
		for(int j=0;j<n;j++)
		{
			if(!(i&j))a[j]=(a[j]+a[i^j]*type+mod)%mod;
		}
	}
}
void fwt_xor(ll *a,int n,int type)
{
	type=type==1?1:mod+1>>1;
	for(int k=1;k<n;k<<=1)
	{
		for(int i=0;i<n;i+=k<<1)
		{
			for(int j=0;j<k;j++)
			{
				ll x=a[i+j],y=a[i+j+k];
				a[i+j]=(x+y)*type%mod;
				a[i+j+k]=(x-y+mod)*type%mod;
			}
		}
	}
}
ll A[N],B[N],a[N],b[N];
template<typename F>
void calc(F f,int n)
{
	for(int i=0;i<n;i++){a[i]=A[i];b[i]=B[i];}
	f(a,n,1);
	f(b,n,1);
	for(int i=0;i<n;i++)a[i]=a[i]*b[i]%mod;
	f(a,n,-1);
	for(int i=0;i<n;i++)cout<<a[i]<<' ';
	cout<<'\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin>>n;
	n=1<<n;
	for(int i=0;i<n;i++)cin>>A[i];
	for(int i=0;i<n;i++)cin>>B[i];
	calc(fmt_or,n);
	calc(fmt_and,n);
	calc(fwt_xor,n);
	return 0;
}
```
